#!/usr/bin/env node

/**
 * vcrypt.js
 *
 * Script CLI de chiffrage de texte.
 *
 * @author    Nicolas DUPRE
 * @release   24.10.2019
 * @version   0.1.0
 *
 */

/**
 * Règles de gestion :
 *
 *    1. Les arguments implicit sont traité en top priorité
 *       Les shortopt sont traités en priorité sur les longopt
 *       Les shortopt et longopt correspondantes sont appended dans le tableau de shortopt
 *
 *
 *    2. Cas des argument(s) d'entrée (text ou fichier) :
 *      Sans fichier(s) de sortie :
 *          -> Flux standard
 *
 *      Avec fichier(s) de sortie n pour n :
 *          -> Dans le fichier de sortie de même index /!\ attention fichier > text /!\
 *
 *      Avec fichier(s) de sortie n pour z :
 *          -> Dans le fichier de sortie de même index /!\ attention fichier > text /!\
 *          -> Le reste dans le flux standard
 *
 *      Note, en cas de fichier en entré introuvable, la sortie
 *      correspondante est ignoré pour ne pas décaller les sorties n pour n ou n pour z.
 *
 *
 *    3. Règle de prioritaire pour entrées combinées :
 *       - Priorité aux fichiers
 *       - Suivis des texts
 *
 *          exemple : -i file1 -t "text1" -i file2 -t "text2" -o for-file1 -o for-file2 -o for-text1 -o for-text2
 *
 *
 *    4. Une seule instruction -c, --crypt ou -d, --decrypt est permise dans la ligne de commande
 *      l'opération -c, --crypt est prioritaire sur -d,--decrypt
 *
 *
 *    5. Le jeu de clés (-k,--key) passés est combinés pour faire le chiffrage/déchiffrage pour les n entrées à crypter
 *
 *
 */


// @TODO : Ajouter un control sur les arguments avec un mode verbeux pour
//         dire que l'argument est specifié, mais qu'il ne respecte pas
//         la configuration spécifiée

/**
 * Chargement des dépendances.
 */
const cli = require('ifopt');
const fs = require('fs');
const sha1 = require('sha1');
const readline = require('readline');
// Caractères individuels (n'accepte pas de valeur)
// Caractères suivis par un deux-points (le paramètre nécessite une valeur)
// Caractères suivis par deux-points (valeur optionnelle)
const options = {
    separator: ",",
    shortopt: "hi:o:cdt:k:s",
    longopt: [
        "help",
        "in-source:",
        "out-source:",
        "crypt",
        "decrypt",
        "text:",
        "keys:",
        "silent",
    ],
};



/**
 * Déclaration des variables globales.
 */
let PWD = process.env.PWD;
let IFILE = null;
let OFILE = null;
let SHOWHELP = true;



/**
 * Déclaration des fonctions.
 */


/**
 * Vérifie si le fichier demandé existe.
 *
 * @param path   Emplacement du fichier à contrôller.
 * @param level  Niveau d'erreur à retourner en cas d'échec.
 *
 * @returns {boolean}
 */
function fileExists(path, level) {
    try {
        fs.accessSync(path, fs.constants.F_OK | fs.constants.W_OK, (err) => {
            if (err) {
                throw err;
            }
        });

        return true;
    } catch(err) {
        cli.log(err, level);
        process.exit();
    }
}

/**
 * Get the file content of the provided file path.
 *
 * @param {String}   file Path to the file we want to get the content.
 *
 * @return {String}  File content
 */
function getFileContent (file) {
    return fs.readFileSync(file, 'utf-8');
}

/**
 * Affiche le manuel d'aide.
 *
 * @param {Number} level  If we display the help next to an invalid command.
 *
 * @return void
 */
function help(level = 0) {
    let name = 'vcryptjs';
    let helpText = `
Usage : ${name} [OPTIONS]

Description here

-h, --help       Display this text.
-o, --out-source Write in this out-file.
-c, --crypt      Crypt the input.
-d, --decrypt    Uncrypt the input.
-i, --in-source  Input file to (un)crypt.
-t, --text       Input text to (un)crypt.
-k, --keys       Input one or more key to encrypt your input.
                 Use separator: ${options.separator}
-s, --silent     Hide INFO message

Details :

  1. Short options have the priority on long options although they are not skipped.
     E.g.: --keys 123 -k 456 (meaning two encryptions are made)
     Key 456 will be used first, then 123 will be used after.
  
  2. Combined sources :
     Files are processed before texts
     E.g.: --in-source file1 -t text1 -i file2 --text text2
     will be process in this order
       1. file2
       2. file1
       3. text1
       4. text2     
  
  3. Inputs & Outputs :
     • Without outputs : Results are displayed in STDOUT
     • With n outpus for n inputs : 
        - Results are redirected in corresponding specified outputs
        - /!\\ Don't forget files are processed before texts /!\\
     • With n outputs for z inputs :
        - Results are redirected in corresponding specified outputs
        - Remaining results are displayed in STDERR
     • /!\\ When a source file failed, the corresponding output is skipped /!\\
     
  4. Only one process can be done at once :
     Crypting (-c,--crypt) have the priority on uncryption (-d, --decrypt).
     
  5. Keys used for encryption must be used in the reverse order to uncryption
     E.g.: -c -k key1 -k key2  ==> -d -k key2 -k key1
    `;

    console.log(helpText);
    if (level) process.exit();
}

/**
 * Vérifie si l'on peu effectuer une opération de chiffrage ou déchiffrage.
 *
 * @return boolean.
 */
function canRun() {
    return (
        (cli.isOption(["i", "in-source", "t", "text"]) || IFILE)
        && cli.isOption(["k", "keys"])
    );
}

/**
 * Get all entered input files.
 *
 * @returns {Array}  List of input files.
 */
function getInputs() {
    let inputs = [];

    if (IFILE) {
        inputs = [IFILE].concat(cli.getOptsValues(['i', 'in-source']));
    }

    return inputs;
}

/**
 * Get all entered output files.
 *
 * @returns {Array}  List of output files.
 */
function getOutpus() {
    let outputs = [];

    if (OFILE) {
        outputs = [OFILE].concat(cli.getOptsValues(['o', 'out-source']));
    }

    return outputs;
}

/**
 * Get all entered texts.
 *
 * @returns {Array} List of texts to crypt.
 */
function getTexts() {
    return cli.getOptsValues(['t', 'text']);
}

/**
 * Return all differents keys to used to perform crypting.
 *
 * @returns {Array}  List of keys.
 */
function getKeys() {
    // Retrieve entered keys
    let allKeys = [];
    let keys = OPTS['keys'] || OPTS['k'];
    keys = keys.val;

    if (!(keys instanceof Array)) {
        keys = [keys];
    }

    // For unique key where user used comma as separator
    // Split them in different key :
    keys.map(function (key) {
        allKeys = allKeys.concat(key.split(options.separator));
    });

    // Perform crypting on key for further processing.
    keys = allKeys.map(function (key) {
        return sha1(key);
    });

    return keys;
}

/**
 * Request the crypting process.
 */
function crypt () {
    postCrypt('crypt');
}

/**
 * Request the uncrypt process.
 */
function decrypt() {
    postCrypt('decrypt');
}

/**
 * Perform the char processing to crypt/uncrypt.
 *
 * @param process
 */
function postCrypt(process) {
    let factor = 1;
    let outIndex = 0;
    let outputContent = null;
    let message = '';

    switch (process) {
        case 'decrypt':
            factor = -1;
            break;
        case 'crypt':
        default:
            factor = 1;
            break;
    }

    let keys = getKeys();
    let inputs = getInputs();
    let texts = getTexts();
    let outputs = getOutpus();

    // Regroupe kind of input to perform the same process :
    let sources = ['file', 'text'];
    sources['file'] = inputs;
    sources['text'] = texts;

    sources.map(function (sourceType) {
        this[sourceType].map(function (source) {
            let inputContent = null;

            switch (sourceType) {
                case 'file':
                    fileExists(source, 1);
                    inputContent = getFileContent(source);
                    break;
                case 'text':
                    inputContent = source;
                    break;
            }

            // Perform crypting
            outputContent = '';

            keys.map(function (key) {
                // When outputContent is not null,
                // We perform once again a crypting over already crypted content
                // So the inputcontent must be those of outputContent
                // Then reset outputContent
                if (outputContent !== '') {
                    inputContent = outputContent;
                    outputContent = '';
                }

                let keyLen = key.length;
                let textLen = inputContent.length;

                for (p = 0; p < textLen; p++) {
                    let kp = p % keyLen;

                    outputContent += String.fromCharCode(
                        inputContent.charCodeAt(p)
                        + (factor * key.charCodeAt(kp))
                    );
                }
            });


            // Return crypted input in corresponding outputs :
            if (outIndex <= (outputs.length - 1)) {
                let output = outputs[outIndex];
                let outputStream = fs.createWriteStream(output, {});
                outputStream.write(outputContent);
                outIndex++;

                message = (sourceType === 'file') ?
                    `The file %s has been ${process}ed in file %s` :
                    `The text %s has been ${process}ed in file %s` ;

                cli.log(message, 0, [source, output]);
            }
            // If no corresponding in front of this input
            // use standard output stream
            else {
                message = (sourceType === 'file') ?
                    `Please find below the ${process}ed content of file %s :` :
                    `Please find below the ${process}ed result of text %s :` ;

                cli.log(message, 0, [source]);
                console.log(outputContent)
            }
        });
    }.bind(sources));
}





/**
 * Lecture des arguments du script.
 */
let implicits = {
    IFILE: null,
    OFILE: null
};
let OPTS = cli.getopt(
    options.shortopt,
    options.longopt,
    ['IFILE', 'OFILE'],
    implicits
);


/**
 * Traitement des options
 */
IFILE = OPTS.in ? OPTS.in.val : OPTS.i ? OPTS.i.val : implicits.IFILE;
OFILE = OPTS.out ? OPTS.out.val : OPTS.o ? OPTS.o.val : implicits.OFILE;

if (OPTS.w || OPTS.write) {
    OFILE = IFILE;
}


/**
 * Traitement en fonction des options
 */
// Afficher l'aide si demandée
if (OPTS.h || OPTS.help) {
    help();
    return true;
}

// Effectuer l'opération de chiffrage.
if (OPTS.c || OPTS.crypt) {
    if (!canRun()) {
        cli.log("Missing option %s and/or %s and %s", 1, ["-i", "-t", "-k"]);
        return false
    }
    crypt();
    return true;
}

// Effectuer l'opération de chiffrage.
if (OPTS.d || OPTS.decrypt) {
    if (!canRun()) {
        cli.log("Missing option %s and/or %s and %s.", 1, ["-i", "-t", "-k"]);
        return false;
    }
    decrypt();
    return true;
}

// Si demandé
if (SHOWHELP) {
    help();
    return true;
}
